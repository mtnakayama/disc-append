#!/usr/bin/env python

from __future__ import annotations

import argparse
from enum import auto, Enum
from pathlib import Path
from collections.abc import Collection
from typing import Optional
from dataclasses import dataclass
import os
import os.path
import subprocess
from webbrowser import get

import humanfriendly


class Command(Enum):
    INIT = auto()
    APPEND = auto()

    @classmethod
    def list_command_options(cls) -> list[str]:
        return [x.name.lower() for x in cls]

    @classmethod
    def from_command_option(cls, value: str) -> Command:
        return cls[value.upper()]


@dataclass
class RunConfig:
    command: Command
    device: Path
    source_paths: Collection[Path]
    dry_run: bool = False
    volume_id: Optional[str] = None


def main():
    run_config = parse_arguments()

    match run_config.command:
        case Command.INIT:
            if run_config.volume_id is None:
                raise RuntimeError("You must specify a Volume ID when initializing a disc.")
        case Command.APPEND:
            if run_config.volume_id is None:
                volume_id = get_volume_id(run_config.device)
                print('Using volume id:', volume_id)
                run_config.volume_id = volume_id

    print_bytes_free(run_config.device)

    approx_write_size = get_size_of_paths(run_config.source_paths)
    human_approx_write_size = humanfriendly.format_size(approx_write_size,
                                                        binary=True)
    print(f'Approx. {human_approx_write_size} to be written.')

    disc_write(run_config)

    if run_config.dry_run:
        print_bytes_after_operation(run_config.device, approx_write_size)
    else:
        print_bytes_free(run_config.device)




def parse_arguments() -> RunConfig:
    parser = argparse.ArgumentParser(description='Modify a multi-session disc.')
    parser.add_argument('command', type=str,
                        choices=Command.list_command_options())
    parser.add_argument('device', type=Path,
                        help='path to destination disc')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--volume-id', '-V',
                        help=('specifies the volume ID (volume name or label) '
                              'to be written into the master block'))
    parser.add_argument('--speed', type=int, default=1,
                        help='the speed to burn the disc')
    parser.add_argument('source_paths', type=Path, nargs='+',
                        help='paths to add to the disc')
    args = parser.parse_args()

    run_config = RunConfig(
        command=Command.from_command_option(args.command),
        device=args.device,
        source_paths=args.source_paths,
        dry_run=args.dry_run,
        volume_id=args.volume_id
    )

    return run_config


def print_bytes_free(device: Path):
    size_left = get_medium_remaining(device)
    human_size_left = humanfriendly.format_size(size_left, binary=True)
    print(f'{human_size_left} bytes free on disc.')


def print_bytes_after_operation(device: Path, operation_write: int):
    size_left = get_medium_remaining(device)
    human_size_left = humanfriendly.format_size(size_left - operation_write,
                                                binary=True)
    print(f'Approx. {human_size_left} will be free after the operation.')


MKISOFS_BASE_ARGS = ['-iso-level', '3', '-l', '-T', '-R', '-J', '--joliet-long']
SESSION_FLAGS = {Command.INIT: '-Z', Command.APPEND: '-M'}


def disc_write(run_config: RunConfig):
    if run_config.volume_id is None:
        raise ValueError("volume_id cannot be none.")

    session_flag = SESSION_FLAGS[run_config.command]

    dry_run_flag = ['--dry-run'] if run_config.dry_run else []

    args = (
        ['growisofs']
        + dry_run_flag
        + [session_flag, str(run_config.device)]
        + MKISOFS_BASE_ARGS
        + ['-V', run_config.volume_id]
        + [str(x) for x in run_config.source_paths]
    )
    print('Executing:', args)

    subprocess.run(args, check=True)


def get_volume_id(device: Path) -> str:
    args = ['blkid', '--output', 'value', '--match-tag', 'LABEL', '/dev/sr0']

    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )

    volume_id = completed_process.stdout.strip()

    return volume_id


def get_size_of_paths(paths: Collection[Path]) -> int:
    return sum(get_size_of_path(x) for x in paths)


def get_size_of_path(path: Path) -> int:
    root_size = path.stat().st_size

    children_size = 0
    for root, dirs, files in os.walk(path):
        children_size += sum(os.stat(os.path.join(root, x)).st_size for x in dirs)
        children_size += sum(os.stat(os.path.join(root, x)).st_size for x in files)

    return root_size + children_size


def get_medium_remaining(device: Path) -> int:
    return get_medium_total_size(device) - get_medium_used(device)


def get_medium_used(device: Path) -> int:
    return get_device_stat(device, 'FSUSED')


def get_medium_total_size(device: Path) -> int:
    return get_device_stat(device, 'SIZE')


def get_device_stat(device: Path, stat_name: str) -> int:
    args = [
        'lsblk', '--output', stat_name, '--noheadings', '--bytes', str(device)
    ]
    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )
    result = int(completed_process.stdout)

    return result


if __name__ == '__main__':
    main()
