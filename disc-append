#!/usr/bin/env python

from __future__ import annotations

import argparse
from enum import auto, Enum
from pathlib import Path
from collections.abc import Collection
from typing import Optional
from dataclasses import dataclass
import subprocess


class Command(Enum):
    INIT = auto()
    APPEND = auto()

    @classmethod
    def list_command_options(cls) -> list[str]:
        return [x.name.lower() for x in cls]

    @classmethod
    def from_command_option(cls, value: str) -> Command:
        return cls[value.upper()]


@dataclass
class RunConfig:
    command: Command
    device: Path
    source_paths: Collection[Path]
    dry_run: bool = False
    volume_id: Optional[str] = None


def main():
    run_config = parse_arguments()

    match run_config.command:
        case Command.INIT:
            if run_config.volume_id is None:
                raise RuntimeError("You must specify a Volume ID when initializing a disc.")
        case Command.APPEND:
            if run_config.volume_id is None:
                run_config.volume_id = get_volume_id(run_config.device)

    disc_write(run_config)


def parse_arguments() -> RunConfig:
    parser = argparse.ArgumentParser(description='Modify a multi-session disc.')
    parser.add_argument('command', type=str,
                        choices=Command.list_command_options())
    parser.add_argument('device', type=Path,
                        help='path to destination disc')
    parser.add_argument('--dry_run', action='store_true')
    parser.add_argument('--volume-id', '-V',
                        help=('specifies the volume ID (volume name or label) '
                              'to be written into the master block'))
    parser.add_argument('source_paths', nargs='+',
                        help='paths to add to the disc')
    args = parser.parse_args()

    run_config = RunConfig(
        command=Command.from_command_option(args.command),
        device=args.device,
        source_paths=args.source_paths,
        dry_run=args.dry_run,
        volume_id=args.volume_id
    )

    return run_config


MKISOFS_BASE_ARGS = ['-iso-level', '3', '-l', '-T', '-R', '-J', '--joliet-long']
SESSION_FLAGS = {Command.INIT: '-Z', Command.APPEND: '-M'}


def disc_write(run_config: RunConfig):
    if run_config.volume_id is None:
        raise ValueError("volume_id cannot be none.")

    session_flag = SESSION_FLAGS[run_config.command]

    dry_run_flag = ['--dry-run']  # if run_config.dry_run else []

    args = (
        ['growisofs']
        + dry_run_flag
        + [session_flag, str(run_config.device)]
        + MKISOFS_BASE_ARGS
        + ['-V', run_config.volume_id]
        + [str(x) for x in run_config.source_paths]
    )
    print('Executing:', args)

    subprocess.run(args, check=True)


def get_volume_id(device: Path) -> str:
    args = ['blkid', '--output', 'value', '--match-tag', 'LABEL', '/dev/sr0']
    print('Executing:', args)

    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )

    volume_id = completed_process.stdout.strip()
    print('Volume id:', volume_id)

    return volume_id


if __name__ == '__main__':
    main()
