#!/usr/bin/env python

from __future__ import annotations

import argparse
from collections.abc import Collection
import dataclasses
from dataclasses import dataclass
from enum import auto, Enum
from pathlib import Path
import subprocess
from typing import Optional

import humanfriendly


class Command(Enum):
    INIT = auto()
    APPEND = auto()

    @classmethod
    def list_command_options(cls) -> list[str]:
        return [x.name.lower() for x in cls]

    @classmethod
    def from_command_option(cls, value: str) -> Command:
        return cls[value.upper()]


@dataclass
class RunConfig:
    command: Command
    device: Path
    source_paths: Collection[Path]
    speed: int
    dry_run: bool = False
    volume_id: Optional[str] = None


def main():
    run_config = parse_arguments()

    match run_config.command:
        case Command.INIT:
            if run_config.volume_id is None:
                raise RuntimeError("You must specify a Volume ID when initializing a disc.")
        case Command.APPEND:
            if run_config.volume_id is None:
                volume_id = get_volume_id(run_config.device)
                print('Using volume id:', volume_id)
                run_config.volume_id = volume_id

    confirmation = confirmation_prompt(run_config)

    if confirmation and not run_config.dry_run:
        disc_write(run_config)
        print_bytes_free(run_config.device)


def confirmation_prompt(run_config: RunConfig) -> bool:
    disc_write(dataclasses.replace(run_config, dry_run=True))

    print_size_approximations(run_config)

    while True:
        key = input("Would you like to proceed? [y/N]:").lower()
        if key == 'y':
            return True
        elif key == 'N' or key == '':
            return False


def print_size_approximations(run_config: RunConfig):
    print_bytes_free(run_config.device)
    approx_write_size = get_bytes_to_be_written(run_config.source_paths)
    print(
        'Approx. '
        f'{humanfriendly.format_size(approx_write_size, binary=True)} '
        'to be written.'
    )
    current_size = get_medium_free(run_config.device)
    size_left = current_size - approx_write_size
    print(
        'Approx. '
        f'{humanfriendly.format_size(size_left, binary=True)} '
        'will be free after the operation.'
    )



def print_bytes_free(device: Path):
    size_left = get_medium_free(device)
    human_size_left = humanfriendly.format_size(size_left, binary=True)
    print(f'{human_size_left} bytes free on disc.')


def parse_arguments() -> RunConfig:
    parser = argparse.ArgumentParser(description='Modify a multi-session disc.')
    parser.add_argument('command', type=str,
                        choices=Command.list_command_options())
    parser.add_argument('device', type=Path,
                        help='path to destination disc')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--volume-id', '-V',
                        help=('specifies the volume ID (volume name or label) '
                              'to be written into the master block'))
    parser.add_argument('--speed', type=int, default=1,
                        help='the speed to burn the disc')
    parser.add_argument('source_paths', type=Path, nargs='+',
                        help='paths to add to the disc')
    args = parser.parse_args()

    run_config = RunConfig(
        command=Command.from_command_option(args.command),
        device=args.device,
        source_paths=args.source_paths,
        dry_run=args.dry_run,
        volume_id=args.volume_id,
        speed=args.speed
    )

    return run_config


MKISOFS_BASE_ARGS = ['-iso-level', '3', '-l', '-T', '-R', '-J', '--joliet-long']
SESSION_FLAGS = {Command.INIT: '-Z', Command.APPEND: '-M'}


def disc_write(run_config: RunConfig):
    if run_config.volume_id is None:
        raise ValueError("volume_id cannot be none.")

    session_flag = SESSION_FLAGS[run_config.command]

    dry_run_flag = ['--dry-run'] if run_config.dry_run else []

    args = (
        ['growisofs']
        + dry_run_flag
        + [f'--speed={run_config.speed}']
        + [session_flag, str(run_config.device)]
        + MKISOFS_BASE_ARGS
        + ['-V', run_config.volume_id]
        + [str(x) for x in run_config.source_paths]
    )
    print('Executing:', args)

    subprocess.run(args, check=True)


def get_bytes_to_be_written(run_config) -> int:
    args = (
        ['mkisofs']
        + MKISOFS_BASE_ARGS
        + ['--print-size', '--quiet']
    )
    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )

    sectors_to_be_written = int(completed_process.stdout)
    bytes_to_be_written = sectors_to_be_written * 2048

    return bytes_to_be_written



def get_volume_id(device: Path) -> str:
    args = ['blkid', '--output', 'value', '--match-tag', 'LABEL', '/dev/sr0']

    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )

    volume_id = completed_process.stdout.strip()

    return volume_id


def get_medium_free(device: Path) -> int:
    return get_medium_total_size(device) - get_medium_used(device)


def get_medium_used(device: Path) -> int:
    return get_device_stat(device, 'FSUSED')


def get_medium_total_size(device: Path) -> int:
    return get_device_stat(device, 'SIZE')


def get_device_stat(device: Path, stat_name: str) -> int:
    args = [
        'lsblk', '--output', stat_name, '--noheadings', '--bytes', str(device)
    ]
    completed_process = subprocess.run(
        args,
        capture_output=True, check=True, text=True
    )
    stat_text = completed_process.stdout.strip()
    result = int(stat_text) if stat_text else 0

    return result


if __name__ == '__main__':
    main()
